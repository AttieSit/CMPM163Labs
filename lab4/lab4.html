<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<link rel="shortcut icon" href=""> 
		<title>Lab 4: Textures & Normal Maps</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script src="../three.js-master/build/three.js"></script>
		<script>
			// setup the scene
      		var scene = new THREE.Scene();
      		var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      		var renderer = new THREE.WebGLRenderer();
      		renderer.setSize(window.innerWidth, window.innerHeight);
      		document.body.appendChild(renderer.domElement);
			camera.position.z = 5;
			
			// setup cubes 1-3
			// cube 2: steel floor texture with normals (second to the left)
			var geometry = new THREE.BoxGeometry();
			var texture1 = THREE.ImageUtils.loadTexture("textures/199.jpg"); //load steel floor diff texture
			var normMap1 = THREE.ImageUtils.loadTexture("textures/199_norm.jpg"); //load steel floor normal texture
			var material1 = new THREE.MeshPhongMaterial( { map: texture1, normalMap: normMap1 } ); 
      		var cube = new THREE.Mesh(geometry, material1);
     		scene.add(cube);
     		cube.position.x -= 2; 
     		// cube 1: steel floor texture no normals (first on the left)
     		var material2 = new THREE.MeshPhongMaterial( { map: texture1 } ); 
     		var cube2 = new THREE.Mesh(geometry, material2);
     		scene.add(cube2);
     		cube2.position.x -= 4;
     		//cube 3: engraved wood texture with normals (third to the left)
     		var texture2 = THREE.ImageUtils.loadTexture("textures/176.jpg"); //load engraved wood diff texture
     		var normMap2 = THREE.ImageUtils.loadTexture("textures/176_norm.jpg"); //load engraved wood normal texture
     		var material3 = new THREE.MeshPhongMaterial( {map: texture2, normalMap: normMap2} ); 
     		var cube3 = new THREE.Mesh(geometry, material3);
     		scene.add(cube3); 

     		// setup cube 4 (fourth to the left)
			// shader variables
			THREE.Cache.enabled = true;
			var count = 0;
			var loader = new THREE.FileLoader();
			var fshader, vshader;
			// load vertex shader
			loader.load('shaders/vertexShader.vert',
      			// onLoad callback
      			function (data) {
      				console.log(data); // output the text to the console
      				vshader = data;
      				count += 1;
      				addNormalMapShaderCube(); 
      			},
      			// onProgress callback
      			function (xhr) {
      				console.log((xhr.loaded/xhr.total * 100)+ '% loaded');
      			},
     			// onError callback
      			function (err) {
      				console.error('An error happened');
      			});
			// load fragment shaders
			loader.load('shaders/fragmentShader.frag',
      			// onLoad callback
      			function (data) {
      				console.log(data); // output the text to the console
      				fshader = data;
      				count += 1;
      				addNormalMapShaderCube(); 
      			},
      			// onProgress callback
      			function (xhr) {
      				console.log((xhr.loaded/xhr.total * 100)+ '% loaded');
      			},
				// onError callback
      			function (err) {
      				console.error('An error happened');
      			});
			// cube 4: custom shader material 
			var geometry2, material4, cube4;
			function addNormalMapShaderCube() {
				if (count == 2) {
					let uniforms = {
						texture3: {type: 'sampler2D', value: new THREE.TextureLoader().load("textures/188.jpg")}, //load pebble diff texture
						colorB: {type: 'vec3', value: new THREE.Color(0xACB6E5)},
						colorA: {type: 'vec3', value: new THREE.Color(0x74ebd5)}
					};
					geometry2 = new THREE.BoxGeometry(1, 1, 1);
					material4 = new THREE.ShaderMaterial({
						uniforms: uniforms,
						fragmentShader: fshader,
						vertexShader: vshader,
						precision: "mediump"});
					cube4 = new THREE.Mesh(geometry2, material4);
					cube4.position.x = 2; 
					scene.add(cube4);
				}
			}

     		// setup cube 5 (fifth to the left)
			// shader variables
			var count2 = 0;
			var loader = new THREE.FileLoader();
			var fshader2, vshader2;
			// load vertex shader
			loader.load('shaders/vertexShader2.vert',
      			// onLoad callback
      			function (data) {
      				console.log(data); // output the text to the console
      				vshader2 = data;
      				count2 += 1;
      				addTiledTextureCube()
      			},
      			// onProgress callback
      			function (xhr) {
      				console.log((xhr.loaded/xhr.total * 100)+ '% loaded');
      			},
     			// onError callback
      			function (err) {
      				console.error('An error happened');
      			});
			// load fragment shaders
			loader.load('shaders/fragmentShader2.frag',
      			// onLoad callback
      			function (data) {
      				console.log(data); // output the text to the console
      				fshader2 = data;
      				count2 += 1;
      				addTiledTextureCube()
      			},
      			// onProgress callback
      			function (xhr) {
      				console.log((xhr.loaded/xhr.total * 100)+ '% loaded');
      			},
				// onError callback
      			function (err) {
      				console.error('An error happened');
      			});
			// cube 5: custom shader material
			var geometry3, material5, cube5;
			function addTiledTextureCube() {
				if (count == 2) {
					let uniforms2 = {
						texture4: {type: 'sampler2D', value: new THREE.TextureLoader().load("textures/178.jpg")}, //load brick diff texture
					};
					geometry3 = new THREE.BoxGeometry(1, 1, 1);
					material5 = new THREE.ShaderMaterial({
						uniforms: uniforms2,
						fragmentShader: fshader2,
						vertexShader: vshader2,
						precision: "mediump"});
					cube5 = new THREE.Mesh(geometry3, material5);
					cube5.position.x = 4; 
					scene.add(cube5);
				}
			}


			// add the light
			var light = new THREE.PointLight(0xffffff, 1, 1000);
			light.position.set(20, 10, 10);
			scene.add(light);

			// create animate method to animate cubes and lights
			var lightDir = -0.3; //set light moving left initially (neg = left/pos = right)
			var lightPosition = 20;
			function animate() {
				requestAnimationFrame(animate);
				//animate light to oscillate on the x-axis
				light.position.x = lightPosition;
				if (light.position.x <= -25) { //left bound
					lightDir = 0.3; //change to move right 
				}else if (light.position.x >= 25) { //right bound
					lightDir = -0.3; //change to move left
				}else{
					//no change
				}
				lightPosition = lightPosition + lightDir;
				light.position.x = lightPosition; //move 
				//console.log("light position = "+lightPosition + lightDir);

				//animate cube 1: steel floor
				//geometry.rotateX(0.01);
				//geometry.rotateY(0.01);

				renderer.render(scene, camera);
			}
			animate();


		</script>
	</body>
</html>
